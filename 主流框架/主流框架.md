# Django，Flask ，Tornado,  FastAPI

## Flask
**Flask的优点：**

轻量级：Flask是一个轻量级的框架，具有简单直观的设计，易于学习和使用。

灵活性：Flask提供了极高的灵活性，开发者可以根据需求选择适合的库和工具。

建设原型快速：Flask提供了快速开发的能力，适用于构建小型项目和原型。

**Flask的缺点：**

缺乏内置功能：相较于其他框架，Flask的内置功能较少，可能需要额外的扩展库。

缺乏标准化：Flask的项目结构因开发者而异，缺少统一的标准化规范。

**Flask的适用情况：**

Flask适合小型和中型项目，以及对选择框架和工具有特定需求的开发者。例如，当你需要快速搭建一个简单的API或快速迭代一个小型项目时，Flask是一个不错的选择。

## Django

**Django的优点：**

全能型框架：Django提供了强大的内置功能，包括ORM、认证、管理界面等，适用于构建复杂的Web应用程序。

完善的文档和庞大的社区支持：Django拥有详尽的文档和庞大的开源社区，提供广泛的支持和解决方案。

可扩展性：Django提供了灵活的扩展机制，可以通过插件和应用增强框架的功能。

**Django的缺点：**

学习曲线较陡峭：相比其他框架，Django具有一定的复杂性，需要一定的学习和熟悉才能高效使用。

性能较低：由于其丰富的内置功能，Django在一些性能方面可能稍逊于其他框架。

**Django的适用情况：**

Django适用于构建大型和复杂的Web应用程序、内容管理系统（CMS）等需要可靠性和安全性的项目。例如，当你需要开发一个包含用户认证、管理界面和复杂数据模型的应用时，选择Django是一个很好的选择。

## FastAPI

**FastAPI的优点：**

高性能：FastAPI是一个基于异步编程的现代化框架，具有出色的性能和低延迟。

自动生成文档：FastAPI能根据代码自动生成互动文档，提高API开发和测试的效率。

类型注解支持：FastAPI支持使用类型注解来提高代码的可读性和可维护性。

快速开发：FastAPI具备快速开发的特点，适用于构建原型、Proof of Concept（POC）和快速迭代的应用。

**FastAPI的缺点：**

较新的项目：FastAPI相对较新，可能在某些方面缺乏成熟的解决方案和社区支持。

学习曲线：对于没有异步编程经验的开发者来说，FastAPI的学习曲线可能较陡峭。

**FastAPI的适用情况：**

FastAPI适用于构建高性能的API和实时应用程序，特别是需要处理大量并发请求和低延迟的项目。例如，当你需要构建一个需要高性能和实时数据交互的应用时，FastAPI是一个非常适合的选择。

## Tornado

Tornado是Facebook开源出来的框架，其哲学跟Django近乎两个极端。

Tornado是异步框架Tornado基本上只算有MVC中C这一层。

轻量、异步非阻塞IO处理方式、出色的抗负载能力、协程带来优异的处理性能。

高性能原因：asyncio调度协程

Tornado能高并发的主要原因就是协程。若想调度协程需要我们自己程序调度，没有办法通过操作系统来调度。因为操作系统调度的最小单位是线程。

Tornado底层协程使用asyncio，所以我们后面可以通过使用asyncio实现的任务调度

 **Tornado的优点:**

少而精（轻量级框架）注重性能优越，速度快
解决高并发（请求处理是基于回调的非阻塞调用）异步非阻塞。
websockets 长连接。内嵌了HTTP服务器。
单线程的异步网络程序，默认启动时根据CPU数量运行多个实例；利用CPU多核的优势。
自定义模块。要性能， Tornado 首选，Tornado适合高度定制，适合访问量大，异步情况多的网站

**Tornado缺点:**

没有ORM,提供的支持和模板少，缺少后台支持，对小型项目来说开发速度没有django快。
模板和数据库部分有很多第三方的模块可供选择，这样不利于封装为一个功能模块 。

## 总结

假设你需要快速构建一个小型的博客应用，可选择Flask。它的灵活性和轻量级特性使得快速开发和原型设计变得容易。

如果你计划开发一个复杂的电子商务网站，需要内置的认证系统和管理界面，Django是一个理想的选择。它的全能性、庞大的社区和文档支持将帮助你构建稳定且功能丰富的应用。

当你打算构建一个高性能的实时数据处理API，需要低延迟和高并发能力时，FastAPI是一个强大的选项。它的异步编程和类型注解支持，使得处理大量并发请求成为可能。

# FastAPI

官网:  [Path Parameters and Numeric Validations - FastAPI (tiangolo.com)](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#__tabbed_1_1)

**FastAPI 都有特点**

- `快速：拥有非常高的性能，归功于 Starlette 和 Pydantic；Starlette 用于路由匹配，Pydantic 用于数据验证`
- `开发效率：功能开发效率提升 200% 到 300%`
- `减少 bug：减少 40% 的因为开发者粗心导致的错误`
- `智能：内部的类型注解非常完善，编辑器可处处自动补全`
- `简单：框架易于使用，文档易于阅读`
- `简短：使代码重复最小化，通过不同的参数声明实现丰富的功能`
- `健壮：可以编写出线上使用的代码，并且会自动生成交互式文档`
- `标准化：兼容 API 相关开放标准`

**FastAPI 最大的特点就是它使用Python 的类型注解**

> **使用 FastAPI 需要 Python 版本大于等于 3.6。**

**首先是 pip install fastapi，会自动安装 Starlette 和 Pydantic；然后还要 pip install uvicorn，因为 uvicorn 是运行相关应用程序的服务器。**

**或者一步到位：pip install fastapi[all]，会将所有依赖全部安装。**

## FastAPI - Uvicorn 服务器

与 Flask 框架不同的是，FastAPI 不包含任何内置的开发服务器。 因此，我们需要**Uvicorn**。 它实现了 **ASGI** 标准，而且速度很快。 ASGI 代表**异步服务器网关接口**。

符合 **WSGI**（Web 服务器网关接口——旧标准）的 Web 服务器不适合 **asyncio** 应用程序。 实现 ASGI 规范的 Python Web 框架（例如 FastAPI）提供高速性能，可与使用 Node 和 Go 构建的 Web 应用程序相媲美。

Uvicorn 使用 **uvloop** 和 **httptools** 库。 它还提供对 HTTP/2 和 WebSockets 的支持，这是 WSGI 无法处理的。 **uvloop** id 类似于内置的 **asyncio** 事件循环。 **httptools** 库处理 http 协议。

如前所述，Uvicorn 的安装将以最少的依赖项进行安装。 但是，标准安装还将安装基于 **cython** 的依赖项以及其他附加库。

```Python
import uvicorn
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def index():
   return {"message": "Hello World"}

if __name__ == "__main__":
   uvicorn.run("main:app", host="127.0.0.1", port=8000, reload=True)
```

现在将此 **app.py** 作为 Python 脚本运行如下 −

```
(fastapienv) C:\fastapienv>python app.py
```

## 请求与响应

### 基本使用

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/int")
async def index1():
    return 666

@app.get("/str")
async def index2():
    return "古明地觉"

@app.get("/bytes")
async def index3():
    return b"satori"

@app.get("/tuple")
async def index4():
    return ("古明地觉", "古明地恋", "雾雨魔理沙")

@app.get("/list")
async def index5():
    return [{"name": "古明地觉", "age": 17}, {"name": "古明地恋", "age": 16}]


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**这里我们直接使用 requests 发请求：**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020241976-1871443980.png)

**只是 `{}` 里面的参数必须要在定义的视图函数的参数中出现, 并且需要规定类型**

通过 Python 的类型声明，FastAPI提供了数据校验的功能，当校验不通过的时候会清楚地指出没有通过的原因。在我们开发和调试的时候，这个功能非常有用。

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/apple/{item_id}")
async def get_item(item_id: int):
    """和 Flask 不同，Flask 定义类型是在路由当中，也就是在 <> 里面，变量和类型通过 : 分隔
       而 FastAPI 是使用类型注解的方式，此时的 item_id 要求一个整型（准确的说是一个能够转成整型的字符串）"""
    return {"item_id": item_id}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020256876-377896880.png)

**如果我们传递的值无法转成整型的话，那么会进行提示：告诉我们 value 不是一个有效的整型，可以看到给的提示信息还是非常清晰的。**

### 交互式文档

**FastAPI 会自动提供一个类似于 Swagger 的交互式文档，我们输入 "localhost:5555/docs" 即可进入。**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020301544-1820133973.png)

**里面的 `/openapi.json`，点击进去，会发现里面包含了定义的路由信息。**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020305424-1782790267.png)

**至于 "localhost:5555/docs" 页面本身，我们也是可以进行设置的：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
import uvicorn

app = FastAPI(title="测试文档",
              description="这是一个简单的 demo",
              docs_url="/my_docs",
              openapi_url="/my_openapi")

@app.get("/apple/{item_id}")
async def get_item(item_id: int):
    """和 Flask 不同，Flask 定义类型是在路由当中，也就是在 <> 里面，变量和类型通过 : 分隔
       而 FastAPI 是使用类型注解的方式，此时的 item_id 要求一个整型（准确的说是一个能够转成整型的字符串）"""
    return {"item_id": item_id}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**重新进入，此时就需要通过 "localhost:5555/my_docs"：**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020311896-986170904.png)

### 路由顺序

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/users/me")
async def read_user_me():
    return {"user_id": "the current user"}

@app.get("/users/{user_id}")
async def read_user(user_id: int):
    return {"user_id": user_id}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**因为路径操作是按照顺序进行的，所以这里要保证 `/users/me` 在 `/users/{user_id}` 的前面，否则的话只会匹配到 `/users/{user_id}`，此时如果访问 `/users/me`，那么会返回一个解析错误，因为字符串 "me" 无法解析成整型。**

### 使用枚举

**将某个路径参数通过类型注解的方式声明为指定为几个值之一的类型（准确的说是可以转成指定的类型，因为默认都是字符串）**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from enum import Enum
from fastapi import FastAPI
import uvicorn

app = FastAPI()

class Name(str, Enum):
    satori = "古明地觉"
    koishi = "古明地恋"
    marisa = "雾雨魔理沙"

@app.get("/users/{user_name}")
async def get_user(user_name: Name):
    return {"user_id": user_name}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**通过枚举的方式可以实现这一点，我们来测试一下：**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020319837-1584815970.png)

**结果和我们期望的是一样的，我们可以再来看看 docs 生成的文档：**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020324247-1660082946.png)

**提示我们，可以用的值：古明地觉、古明地恋、雾雨魔理沙。**

### 路径中包含 /

**假设我们有这样一个路由：`/files/{file_path}`，而用户传递的 file_path 中显然是可以带 `/` 的，假设 file_path 是 `/root/test.py`，那么路由就变成了 `/files//root/test.py`，显然这是有问题的。**

**解决方式:**

```Python
from fastapi import FastAPI
import uvicorn

app = FastAPI()


# 声明 file_path 的类型为 path，这样它会被当成一个整体
@app.get("/files/{file_path:path}")
async def get_file(file_path: str):
    return {"file_path": file_path}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020330506-93702716.png)

### 查询参数

#### 基本使用

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/user/{user_id}")
async def get_user(user_id: str, name: str, age: int):
    """我们在函数中参数定义了 user_id、name、age 三个参数
       显然 user_id 和 路径参数中的 user_id 对应，然后 name 和 age 会被解释成查询参数
       这三个参数的顺序没有要求，但是一般都是路径参数在前，查询参数在后
    """
    return {"user_id": user_id, "name": name, "age": age}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020337041-1623829437.png)

#### **默认值**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/user/{user_id}")
async def get_user(user_id: str, name: str = "UNKNOWN", age: int = 0):
    return {"user_id": user_id, "name": name, "age": age}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020344466-1005417569.png)

#### Union和None

3.10

```python
def process_item(item: int | str):
    print(item)
```

```python
def say_hi(name: str | None = None):  #默认为空
    if name is not None:
        print(f"Hey {name}!")
    else:
        print("Hello World")
```

3.8

```python
from typing import Union

def process_item(item: Union[int, str]):
    print(item)
```

```python
from typing import Optional

def say_hi(name: Optional[str] = None):
    if name is not None:
        print(f"Hey {name}!")
    else:
        print("Hello World")
```

**例子**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Union, Optional
from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/user/{user_id}")
async def get_user(user_id: Union[int, str], name: Optional[str] = None):
    """user_id, 通过Union 来声明一个混合类型，int 在前、str 在后。会先按照 int 解析，解析失败再变成 str
        name，它表示字符串类型、但默认值为 None（不是字符串），那么应该声明为 Optional[str]"""
    return {"user_id": user_id, "name": name}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020356318-2147151253.png)

#### bool 类型自动转换

**对于布尔类型，FastAPI 支持自动转换**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/{flag}")
async def get_flag(flag: bool):
    return {"flag": flag}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020402797-86509243.png)

#### 多个路径和查询参数

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Optional
from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/postgres/{schema}/v1/{table}")
async def get_data(schema: str,
                   table: str,
                   select: str = "*",
                   where: Optional[str] = None,
                   limit: Optional[int] = None,
                   offset: Optional[int] = None):
    """标准格式是：路径参数按照顺序在前，查询参数在后
       但其实对顺序是没有什么要求的"""
    query = f"select {select} from {schema}.{table}"
    if where:
        query += f" where {where}"
    if limit:
        query += f" limit {limit}"
    if offset:
        query += f" offset {offset}"
    return {"query": query}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**然后我们使用 requests 来测试一下：**

```Python
print(
    requests.get("http://localhost:5555/postgres/ods/v1/staff").json()
)  # {'query': 'select * from ods.staff'}
print(
    requests.get("http://localhost:5555/postgres/ods/v1/staff?select=id, name&where=id > 3&limit=100").json()
)  # {'query': 'select id, name from ods.staff where id > 3 limit 100'}
```

#### Depends

 Depends的两种用法:

+  Depends(function)形式

+ Depends(class)形式 (推荐)

 Depends(function)形式

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Optional
import uvicorn
from fastapi import Depends, FastAPI

app = FastAPI()

async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}

@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    # common_parameters 接收三个参数：q、skip、limit
    # 然后在解析请求的时候，会将 q、skip、limit 传递到 common_parameters 中，然后将返回值赋值给 commons
    # 但如果解析不到某个参数时，那么会判断函数中参数是否有默认值，没有的话就会返回错误，而不是传递一个 None 进去
    return commons

@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons

if __name__ == "__main__":
    uvicorn.run("main1:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020610489-2006340114.png)

Depends(class)形式 (推荐)

```Python
import uvicorn
from fastapi import Depends, FastAPI
from typing import Optional
 
from pydantic import BaseModel
 
app = FastAPI()

class CommonQueryParams:
    def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit
 
 
@app.get("/items")
async def read_items(common=Depends(CommonQueryParams)):
    return common
 
 
if __name__ == '__main__':
    uvicorn.run(app, host="0.0.0.0", port=8080, loop="asyncio")
```

![image-20240102194704434](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/image-20240102194704434.png)

**实际项目中的应用-Depends(database_connection)**

**因此当有共享的逻辑、或者共享的数据库连接、增强安全性、身份验证、角色权限等等，会非常的实用。**

在实际项目中，后端开发时，用到的比较多的Depends比较多的是3个场景：

- Depends(current_user)  在路由函数中，经常需要知道当前的用户是谁，用一个def get_current_user()方法实现获取，然后Depends(current_user)
- Depends(database)  创建数据库session，特别常用，使用def connecton()获取数据库session，然后Depends(connection)，看举例代码
- Depends(common_params) 有一些公共参数，可以提取出来，然后使用Depends(common_params)

**Depends(databse)来获取数据库seesion**

```python
# db.py用于初始化数据库
# 执行db.init(config)
 
import logging
from urllib.parse import quote_plus
 
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, scoped_session
 
context = {
    "db_url": None,
    "engine": None,
    "smaker": None
}
 
scoped_context = {
    "db_url": None,
    "engine": None,
    "smaker": None
}
 
logs = logging.getLogger("sqlalchemy")
 
 
def init(config):
    db_url, engine, smaker = make_context(config)
    logs.debug("try to crate all database objects")
    Base.metadata.create_all(engine)  # 创建所有数据表
 
    context["db_url"] = db_url
    context["engine"] = engine
    context["smaker"] = smaker
 
    scoped_context["db_url"] = db_url
    scoped_context["engine"] = engine
    scoped_context["smaker"] = scoped_session(smaker)
 
 
def make_context(c):
    logs.debug("database config: %s", c)
 
    db_url = make_url(c)
    engine = create_engine(
        db_url,
        encoding=c.get("encoding" "utf8"),
        echo=c.get("echo", False),
        echo_pool=c.get("echo_pool", False),
        pool_recycle=c.get("pool_recycle", 3600),
        pool_size=c.get("(pool_size", 256)
    )
 
    smaker = sessionmaker(bind=engine, expire_on_commit=c.get("expire_on_commit", False))
    logs.debug("create session maker")
 
    return db_url, engine, smaker
 
 
def make_url(c):
    protocol = c["protocol"]
    username = c["username"]
    password = c["password"]
    password = quote_plus(password)
    host = c["host"]
    port = c["port"]
    database = c["database"]
 
    template = "{}://{}:{}@{}:{}/{}"
    db_url = template.format(protocol, username, password, host, port, database)
    url_tip = template.format(protocol, username, "XXXXXX", host, port, database)
    logs.debug(f"create db engine to {url_tip}")
 
    return db_url
 
 
def make_session(ctx=None, scoped=False):
    c = ctx if ctx is not None else (scoped_context if scoped else context)
    m = c["smaker"]
    s = m()
    return s
 
 
@contextlib.contextmanager
def session_context(ctx=None, scoped=False):
    session = make_session(ctx, scoped)
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.colse()
 
 
def connection():
    with session_context() as session:
        yield session
```



```python
import uvicorn
from fastapi import Depends, FastAPI
 
app = FastAPI()
 
 
@app.get("/items")
async def read_items(database=Depends(connection)):
    # 这里的connection就是一个mysql的session连接了
    data = database.query("selext xxx from yyy")
    return data
 
 
@app.get("/users")
async def read_items(database=Depends(connection)):
    # 这里的connection就是一个mysql的session连接了
    data = database.query("selext xxx from user")
    return data
 
 
if __name__ == '__main__':
    uvicorn.run(app, host="0.0.0.0", port=8080, loop="asyncio")
```

每次需要使用数据库操作时，就很方便了。

### 查询参数和数据校验(3.8)

**FastAPI 支持我们进行更加智能的数据校验，比如一个字符串，我们希望用户在传递的时候只能传递长度为 6 到 15 的字符串该怎么做呢？**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Optional
from fastapi import FastAPI, Query
import uvicorn

app = FastAPI()

@app.get("/user")
async def check_length(
        # 默认值为 None，应该声明为 Optional[str]，当然声明 str 也是可以的。只不过声明为 str，那么默认值应该也是 str
        # 所以如果一个类型允许为空，那么更规范的做法应该是声明为 Optional[类型]。
        password: Optional[str] = Query(None, min_length=6, max_length=15)
):
    return {"password": password}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**password 是可选的，但是一旦传递则必须传递字符串、而且还是长度在 6 到 15 之间的字符串。所以如果传递的是 None，那么在声明默认值的时候 None 和 Query(None) 是等价的，只不过 Query 还支持其它的参数来对参数进行限制。**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020637151-527221813.png)

**Query 里面除了限制最小长度和最大长度，还有其它的功能：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, Query
import uvicorn

app = FastAPI()


@app.get("/user")
async def check_length(
        password: str = Query("satori", min_length=6, max_length=15, regex=r"^satori")
):
    """此时的 password 默认值为 'satori'，并且传递的时候必须要以 'satori' 开头
       但是值得注意的是 password 后面的是 str，不再是 Optional[str]，因为默认值不是 None 了
       当然这里即使写成 Optional[str] 也是没有什么影响的
    """
    return {"password": password}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020643668-261817598.png)

#### 声明为必须参数

**我们通过 Query 可以限制参数的长度，但是问题来了，这个时候我还希望这个参数是必传的该怎么做呢？**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, Query
import uvicorn

app = FastAPI()

@app.get("/user")
async def check_length(
        password: str = Query(..., min_length=6)
):
    """将第一个参数换成 ... 即可实现该参数是必传参数
    """
    return {"password": password}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020651429-1933579876.png)

**... 是 Python 中的一个特殊的对象，可以了解一下，通过它可以实现该参数是必传参数。**

#### 查询参数变成一个列表

**如果我们指定了 `a=1&a=2`，那么我们在获取 a 的时候如何才能得到一个列表呢？**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Optional, List
from fastapi import FastAPI, Query
import uvicorn

app = FastAPI()

@app.get("/items")
async def read_items(
        a1: str = Query(...),
        a2: List[str] = Query(...),
        b: List[str] = Query(...)
):
    return {"a1": a1, "a2": a2, "b": b}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**我们访问一下，看看结果：**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020658221-928100483.png)

**首先 "a2" 和 "b" 都是对应列表，然后 "a1" 只获取了最后一个值。另外可能有人觉得我们这样有点啰嗦，在函数声明中可不可以这样写呢？**

```Python
@app.get("/items")
async def read_items(
        a1: str,
        a2: List[str],
        b: List[str]
):
    return {"a1": a1, "a2": a2, "b": b}
```

**对于 a1 是可以的，但是 a2 和 b 不行。对于类型为 list 的查询参数，无论有没有默认值，你都必须要显式的加上 Query 来表示必传参数。如果允许为 None（或者有默认值）的话，那么应该这么写：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Optional, List
from fastapi import FastAPI, Query
import uvicorn

app = FastAPI()


@app.get("/items")
async def read_items(
        a1: str,
        a2: Optional[List[str]] = Query(None),
        b: List[str] = Query(["1", "嘿嘿"])
):
    return {"a1": a1, "a2": a2, "b": b}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020705385-1271516357.png)

#### 给参数起别名

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Optional, List
from fastapi import FastAPI, Query
import uvicorn

app = FastAPI()

@app.get("/items")
async def read_items(
        # 通过 url 的时候使用别名即可
        item1: Optional[str] = Query(None, alias="item-query"),
        item2: str = Query("哈哈", alias="@@@@"),
        item3: str = Query(..., alias="$$$$")  # item3 是必传的
):
    return {"item1": item1, "item2": item2, "item3": item3}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020711384-1642242466.png)

#### 数值检测

**Query 不仅仅支持对字符串的校验，还支持对数值的校验，里面可以传递 gt、ge、lt、le 这几个参数，举例说明：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, Query
import uvicorn

app = FastAPI()

@app.get("/items")
async def read_items(
        # item1 必须大于 5
        item1: int = Query(..., gt=5),
        # item2 必须小于等于 7
        item2: int = Query(..., le=7),
        # item3 必须必须等于 10
        item3: int = Query(..., ge=10, le=10)
):
    return {"item1": item1, "item2": item2, "item3": item3}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020717770-1886459232.png)

### 路径参数和数据校验(3.8)

**查询参数数据校验使用的是 Query，路径参数数据校验使用的是 Path，两者的使用方式一模一样，没有任何区别。**

```Python
from fastapi import FastAPI, Path
import uvicorn

app = FastAPI()

@app.get("/items/{item-id}")
async def read_items(item_id: int = Path(..., alias="item-id")):
    return {"item_id": item_id}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**因为路径参数是必须的，它是路径的一部分，所以我们应该使用 ... 将其标记为必传参数。当然即使不这么做也无所谓，因为指定了默认值也用不上，因为路径参数不指定压根就匹配不到相应的路由。至于一些其它的校验，和查询参数一模一样，所以这里不再赘述了。**

**不过我们之前说过，路径参数应该在查询参数的前面，尽管 FastAPI 没有这个要求，但是这样写明显更舒服一些。但是问题来了，如果路径参数需要指定别名，但是某一个查询参数不需要，这个时候就会出现问题：**

```Python
@app.get("/items/{item-id}")
async def read_items(q: str,
                     item_id: int = Path(..., alias="item-id")):

    return {"item_id": item_id, "q": q}
```

**显然此时 Python 的语法就决定了 item_id 就必须放在 q 的后面，当然这么做是完全没有问题的，FastAPI 对参数的先后顺序没有任何要求，因为它是通过参数的名称、类型和默认值声明来检测参数，而不在乎参数的顺序。但此时我们就要让 item_id 在 q 的前面要怎么做呢？**

```Python
@app.get("/items/{item-id}")
async def read_items(*, item_id: int = Path(..., alias="item-id"),
                     q: str):
    
    return {"item_id": item_id, "q": q}
```

**此时就没有问题了，通过将第一个参数设置为 \*，使得 item_id 和 q 都必须通过关键字传递，所以此时默认参数在非默认参数之前也是允许的。当然我们也不需要担心 FastAPI 传参的问题，你可以认为它所有的参数都是通过关键字参数的方式传递的。**

### Request

**任何一个请求都对应一个 Request 对象，请求的所有信息都在这个 Request 对象中，FastAPI 也不例外。**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, Request
import uvicorn

app = FastAPI()


@app.get("/girl/{user_id}")
async def read_girl(user_id: str,
                    request: Request):
    """路径参数是必须要体现在参数中，但是查询参数可以不写了
       因为我们定义了 request: Request，那么请求相关的所有信息都会进入到这个 Request 对象中"""
    header = request.headers  # 请求头
    method = request.method  # 请求方法
    cookies = request.cookies  # cookies
    query_params = request.query_params  # 查询参数
    return {"name": query_params.get("name"), "age": query_params.get("age"), "hobby": query_params.getlist("hobby")}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**我们通过 Request 对象可以获取所有请求相关的信息，我们之前当参数传递不对的时候，FastAPI 会自动帮我们返回错误信息，但通过 Request 我们就可以自己进行解析、自己指定返回的错误信息了。**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020727148-1958643935.png)

### Response

**尽管可以直接返回一个字典，但 FastAPI 实际上会帮我们转成一个 Response 对象。**

**Response 内部接收如下参数：**

- `content：返回的数据`
- `status_code：状态码`
- `headers：返回的请求头`
- `media_type：响应类型(就是 HTML 中 Content-Type，只不过这里换了个名字)`
- `background：接收一个任务，Response 在返回之后会自动异步执行（这里不做介绍，后面会说）`

**举个栗子：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, Request, Response
import uvicorn
import orjson

app = FastAPI()


@app.get("/girl/{user_id}")
async def read_girl(user_id: str,
                    request: Request):
    query_params = request.query_params  # 查询参数
    data = {"name": query_params.get("name"), "age": query_params.get("age"), "hobby": query_params.getlist("hobby")}
    # 实例化一个 Response 对象
    response = Response(
        # content，我们需要手动转成 json 字符串，如果直接返回字典的话，那么在包装成 Response 对象的时候会自动帮你转
        orjson.dumps(data),
        # status_code，状态码
        201,
        # headers，响应头
        {"Token": "xxx"},
        # media_type，就是 HTML 中的 Content-Type
        "application/json",  
    )
    # 如果想设置 cookie 的话，那么通过 response.set_cookie 即可
    # 删除 cookie 则是 response.delete_cookie
    return response


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**通过 Response 我们可以实现请求头、状态码、cookie 等自定义。**

**另外除了 Response 之外还有很多其它类型的响应，它们都在 fastapi.responses 中，比如：FileResponse、HTMLResponse、PlainTextResponse 等等。它们都继承了 Response，只不过会自动帮你设置响应类型，举个栗子：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
from fastapi.responses import Response, HTMLResponse
import uvicorn

app = FastAPI()


@app.get("/index")
async def index():

    response1 = HTMLResponse("<h1>你好呀</h1>")
    response2 = Response("<h1>你好呀</h1>", media_type="text/html")
    # 以上两者是等价的，在 HTMLResponse 中会自动将 media_type 设置成 text/html
    return response1


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

### 其它类型的请求与响应

**FastAPI 除了 GET 请求之外，还支持其它类型，比如：POST、PUT、DELETE、OPTIONS、HEAD、PATCH、TRACE 等等。而常见的也就 GET、POST、PUT、DELETE**

**显然对应 POST、PUT 等类型的请求，我们必须要能够解析出请求体，并且能够构造出响应体。**

#### Model

**在 FastAPI 中，请求体和响应体都对应一个 Model，举个栗子：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Optional, List
from fastapi import FastAPI, Request, Response
from pydantic import BaseModel
import uvicorn

app = FastAPI()


class Girl(BaseModel):
    """数据验证是通过 pydantic 实现的，我们需要从中导入 BaseModel，然后继承它"""
    name: str
    age: Optional[str] = None
    length: float
    hobby: List[str]  # 对于 Model 中的 List[str] 我们不需要指定 Query（准确的说是 Field）


@app.post("/girl")
async def read_girl(girl: Girl):
    # girl 就是我们接收的请求体，它需要通过 json 来传递，并且这个 json 要有上面的四个字段（age 可以没有）
    # 通过 girl.xxx 的方式我们可以获取和修改内部的所有属性
    return dict(girl)  # 直接返回 Model 对象也是可以的


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020738946-239091009.png)

**除了使用这种方式之外，我们还可以使用之前说的 Request 对象：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, Request
import uvicorn

app = FastAPI()

@app.post("/girl")
async def read_girl(request: Request):
    # 是一个协程，所以需要 await
    data = await request.body()
    print(data)

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**首先我们在使用 requests 模块发送 post 请求的时候可以通过 data 参数传递、也可以通过 json 参数。**

**当通过 `json={"name": "satori", "age": 16, "length": 155.5}` 传递的时候，会将其转成 json 字符串进行传输，程序中的 print 打印如下：**

```Python
b'{"name": "satori", "age": 16, "length": 155.5}'
```

**如果我们是用过 data 参数发请求的话（值不变），那么会将其拼接成 `k1=v1&k2=v2` 的形式再进行传输（相当于表单提交，后面说），程序中打印如下：**

```Python
b'name=satori&age=16&length=155.5'
```

**所以我们看到 await request.body() 得到的就是最原始的字节流，而除了 await request.body() 之外还有一个 await request.json()，只是后者在内部在调用了前者拿到字节流之后、自动帮你 loads 成了字典。因此使用 await request.json() 也侧面要求，我们必须在发送请求的时候必须使用 json 参数传递（传递的是字典转成的 json、所以也能解析成字典），否则使用 await request.json() 是无法正确解析的。**

#### 路径参数、查询参数、请求体

**我们可以将三者混合在一起：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Optional, List
from fastapi import FastAPI, Request, Response
from pydantic import BaseModel
import uvicorn

app = FastAPI()


class Girl(BaseModel):
    name: str
    age: Optional[str] = None
    length: float
    hobby: List[str]


@app.post("/girl/{user_id}")
async def read_girl(user_id,
                    q: str,
                    girl: Girl):

    return {"user_id": user_id, "q": q, **dict(girl)}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020747937-2071146814.png)

**里面我们同时指定了路径参数、查询参数和请求体，FastAPI 依然是可以正确区分的，当然我们也可以使用 Request 对象。**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Optional, List, Dict
from fastapi import FastAPI, Request, Response
from pydantic import BaseModel
import uvicorn

app = FastAPI()

@app.post("/girl/{user_id}")
async def read_girl(user_id,
                    request: Request):

    q = request.query_params.get("q")
    data: Dict = await request.json()
    data.update({"user_id": user_id, "q": q})
    return data


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**可以自己测试一下，仍然是可以正确返回的。**

#### 多个请求体参数

**我们上面的只接收一个 json 请求体，如果是接收两个呢？**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Optional, List
from fastapi import FastAPI, Request, Response
from pydantic import BaseModel
import uvicorn

app = FastAPI()


class Girl(BaseModel):
    name: str
    age: Optional[str] = None


class Boy(BaseModel):
    name: str
    age: int


@app.post("/boy_and_girl")
async def read_boy_and_girl(girl: Girl,
                            boy: Boy):
    return {"girl": dict(girl), "boy": dict(boy)}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**此时在传递的时候，应该按照如下方式传递：**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020755635-1729462211.png)

**应该将两个 json 嵌套在一起，组成一个更大的 json，至于 key 就是我们的函数参数名。因此这种方式其实就等价于：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import Optional, List, Dict
from fastapi import FastAPI, Request, Response
from pydantic import BaseModel
import uvicorn

app = FastAPI()

class BoyAndGirl(BaseModel):
    girl: Dict
    boy: Dict

@app.post("/boy_and_girl")
async def read_boy_and_girl(boy_and_girl: BoyAndGirl):
    return dict(boy_and_girl)

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**这种方式也是可以实现的，只不过就字典内部的字典的不可进行限制了。当然啦，我们仍然可以使用 Request 对象，得到字典之后自己再进行判断，因为对于 json 而言，内部的字段可能是会变的，而且最关键的是字段可能非常多。这个时候，我个人更倾向于使用 Request 对象。**

#### Form 表单

**我们调用 requests.post，如果参数通过 data 传递的话，则相当于提交了一个 form 表单，那么在 FastAPI 中可以通过 await request.form() 进行获取，注意：内部同样是先调用 await request.body()。**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, Request, Response
import uvicorn

app = FastAPI()

@app.post("/girl")
async def girl(request: Request):
    # 此时 await request.json() 报错，因为是通过 data 参数传递的，相当于 form 表单提交
    # 如果是通过 json 参数传递，那么 await request.form() 会得到一个空表单
    form = await request.form()
    return [form.get("name"), form.getlist("age")]

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020802874-121302159.png)

**当然我们也可以通过其它方式：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, Form
import uvicorn

app = FastAPI()

@app.post("/user")
async def get_user(username: str = Form(...),
                   password: str = Form(...)):
    return {"username": username, "password": password}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020808592-831609254.png)

**像 Form 表单，查询参数、路径参数等等，都可以和 Request 对象一起使用，像上面的例子，如果我们多定义一个 request: Request，那么我们仍然可以通过 await request.form() 拿到相关的表单信息。所以如果你觉得某个参数不适合类型注解，那么你可以单独通过 Request 对象进行解析。**

#### 文件上传

**那么问题来了，FastAPI 如何接收用户的文件上传呢？首先如果想使用文件上传功能，那么你必须要安装一个包 python-multipart，直接 pip install python-multipart 即可。**

```python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, File, UploadFile
import uvicorn

app = FastAPI()

@app.post("/file1")
async def file1(file: bytes = File(...)):
    return f"文件长度: {len(file)}"

@app.post("/file2")
async def file1(file: UploadFile = File(...)):
    return f"文件名: {file.filename}, 文件大小: {len(await file.read())}"


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020814775-629367944.png)

**我们看到一个直接获取字节流，另一个是获取类似于文件句柄的对象。如果是多个文件上传要怎么做呢？**

```python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from typing import List
from fastapi import FastAPI, UploadFile, File
import uvicorn

app = FastAPI()

@app.post("/file")
async def file(files: List[UploadFile] = File(...)):
    """指定类型为列表即可"""
    for idx, f in enumerate(files):
        files[idx] = f"文件名: {f.filename}, 文件大小: {len(await f.read())}"
    return files

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020820549-1201607854.png)

**此时我们就实现了 FastAPI 文件上传，当然文件上传并不影响我们处理表单，可以自己试一下同时处理文件和表单。**

### 返回静态资源

**下面来看看 FastAPI 如何返回静态资源，首先我们需要安装 aiofiles，直接 pip 安装即可。**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
import uvicorn

app = FastAPI()

# name 参数只是起一个名字，FastAPI 内部使用
app.mount("/static", StaticFiles(directory=r"C:\Users\satori\Desktop\bg"), name="static")

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**浏览器输入：localhost:5555/static/1.png，那么会返回 C:\Users\satori\Desktop\bg 下的 1.png 文件。**

## 错误处理

**错误处理也是一个不可忽视的点，错误有很多种，比如：**

- `客户端没有足够的权限执行此操作`
- `客户端没有访问某个资源的权限`
- `客户端尝试访问一个不存在的资源`
- `...`

**这个时候我们应该将错误通知相应的客户端，这个客户端可以浏览器、代码程序、IoT 设备等等。**

**但是就我个人而言，更倾向于使用 Response 对象，将里面的 status_code 设置为 404，然后在返回的 json 中指定错误信息。不过 FastAPI 内部也提供了一些异常类：**

```python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, HTTPException
import uvicorn

app = FastAPI()

@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id != "foo":
        # 里面还可以传入 headers 设置响应头
        raise HTTPException(status_code=404, detail="item 没有发现")
    return {"item": "bar"}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020828671-1443852811.png)

**HTTPException 是一个普通的 Python 异常类（继承了 Exception），它携带了 API 的相关信息，既然是异常，那么我们不能 return、而是要 raise。**

**个人觉得这个不是很常用，至少我本人很少用这种方式返回错误，因为它能够携带的信息太少了。**

### 自定义异常

**FastAPI 内部提供了一个 HTTPException，但是我们也可以自定义，但是注意：我们自定义完异常之后，还要定义一个 handler，将异常和 handler 绑定在一起，然后引发该异常的时候就会触发相应的 handler。**

```Python
from fastapi import FastAPI, Request
from fastapi.responses import ORJSONResponse
import uvicorn

app = FastAPI()


class ASCIIException(Exception):
    """何もしません"""

# 通过装饰器的方式，将 ASCIIException 和 ascii_exception_handler 绑定在一起
@app.exception_handler(ASCIIException)
async def ascii_exception_handler(request: Request, exc: ASCIIException):
    """当引发 ASCIIException 的时候，会触发 ascii_exception_handler 的执行
       同时会将 request 和 exception 传过去"""
    return ORJSONResponse(status_code=404, content={"code": 404, "message": "你必须传递 ascii 字符串"})

@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if not item_id.isascii():
        raise ASCIIException
    return {"item": f"get {item_id}"}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020834946-1479609504.png)

**关于 Request、Response，我们除了可以通过 fastapi 进行导入，还可以通过 starlette 进行导入，因为 fastapi 的路由映射是通过 starlette 来实现的。当然我们直接从 fastapi 中进行导入即可。**

### 自定义 404

**当访问一个不存在的 URL，我们应该提示用户，比如：您要找到页面去火星了。**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
from fastapi.responses import ORJSONResponse
from fastapi.exceptions import StarletteHTTPException
import uvicorn

app = FastAPI()

@app.exception_handler(StarletteHTTPException)
async def not_found(request, exc):
    return ORJSONResponse({"code": 404, "message": "您要找的页面去火星了。。。"})

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**此时当我们访问一个不存在的 URL 时，就会返回我们自定义的 JSON 字符串。**

## 后台任务

**如果一个请求耗时特别久，那么我们可以将其放在后台执行，而 FastAPI 已经帮我们做好了这一步。我们来看一下：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
import time
from fastapi import FastAPI, BackgroundTasks
import uvicorn

app = FastAPI()

def send_email(email: str, message: str = ""):
    """发送邮件，假设耗时三秒"""
    time.sleep(3)
    print(f"三秒之后邮件发送给 {email!r}, 邮件信息: {message!r}")

@app.get("/user/{email}")
async def order(email: str, bg_tasks: BackgroundTasks):
    """这里需要多定义一个参数
       此时任务就被添加到后台，当 Response 对象返回之后触发"""
    bg_tasks.add_task(send_email, email, message="这是一封邮件")
    # 我们在之前介绍 Response 的时候说过，里面有一个参数 background
    # 所以我们也可以将任务放在那里面
    # 因此我们还可以：
    # return Response(orjson.dumps({"message": "邮件发送成功"}), background=BackgroundTask(send_email, email, message="这是一封邮件"))
    return {"message": "邮件发送成功"}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**首先请求肯定是成功的：**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020841817-1454435321.png)

**然后响应的 3 秒，终端会出现如下打印：**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020846715-232592255.png)

**所以此时任务是被后台执行了的，注意：任务是在响应返回之后才后台执行。**

## APIRouter

**APIRouter 类似于 Flask 中的蓝图，可以更好的组织大型项目，举个栗子：**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020852661-1817862168.png)

**在我当前的工程目录中有一个 app 目录和一个 main.py，其中 app 目录中有一个 app01.py，然后我们看看它们是如何组织的。**

```Python
# app/app01.py
from fastapi import APIRouter

router = APIRouter(prefix="/router")

# 以后访问的时候要通过 /router/v1 来访问
@router.get("/v1")
async def v1():
    return {"message": "hello world"}


# main.py
from fastapi import FastAPI
from app.app01 import router
import uvicorn

app = FastAPI()

# 将 router 注册到 app 中，相当于 Flask 中的 register_blueprint
app.include_router(router)

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**然后可以在外界通过 /router/v1 的方式来访问。**

## 中间件

**中间件在 web 开发中可以说是非常常见了，说白了中间件就是一个函数或者一个类。在请求进入视图函数之前，会先经过中间件（被称为请求中间件），而在中间件里面，我们可以对请求进行一些预处理，或者实现一个拦截器等等；同理当视图函数返回响应之后，也会经过中间件（被称为响应中间件），在中间件里面，我们也可以对响应进行一些润色。**

#### 自定义中间件

**在 FastAPI 里面也支持像 Flask 一样自定义中间件，但是 Flask 里面有请求中间件和响应中间件，但是在 FastAPI 里面这两者合二为一了，我们看一下用法。**

```python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, Request, Response
import uvicorn
import orjson

app = FastAPI()


@app.get("/")
async def view_func(request: Request):
    return {"name": "古明地觉"}


@app.middleware("http")
async def middleware(request: Request, call_next):
    """
    定义一个协程函数，然后使用 @app.middleware("http") 装饰，即可得到中间件
    """
    # 请求到来时会先经过这里的中间件
    if request.headers.get("ping", "") != "pong":
        response = Response(content=orjson.dumps({"error": "请求头中缺少指定字段"}),
                            media_type="application/json",
                            status_code=404)
        # 当请求头中缺少 "ping": "pong"，在中间件这一步就直接返回了，就不会再往下走了
        # 所以此时就相当于实现了一个拦截器
        return response
    # 然后，如果条件满足，则执行 await call_next(request)，关键是这里的 call_next
    # 如果该中间件后面还有中间件，那么 call_next 就是下一个中间件；如果没有，那么 call_next 就是对应的视图函数
    # 这里显然是视图函数，因此执行之后会拿到视图函数返回的 Response 对象
    # 所以我们看到在 FastAPI 中，请求中间件和响应中间件合在一起了
    response: Response = await call_next(request)
    # 这里我们在设置一个响应头
    response.headers["status"] = "success"
    return response


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**我们可以测试一下：**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20211008210110868-1185095001.png)

**测试结果也印证了我们的结论。**

#### 内置的中间件

**通过自定义中间件，我们可以在不修改视图函数的情况下，实现功能的扩展。但是除了自定义中间件之外，FastAPI 还提供了很多内置的中间件。**

```python
app = FastAPI()

# 要求请求协议必须是 https 或者 wss，如果不是，则自动跳转
from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware
app.add_middleware(HTTPSRedirectMiddleware)

# 请求中必须包含 Host 字段，为防止 HTTP 主机报头攻击，并且添加中间件的时候，还可以指定一个 allowed_hosts，那么它是干什么的呢？
# 假设我们有服务 a.example.com, b.example.com, c.example.com
# 但我们不希望用户访问 c.example.com，就可以像下面这么设置，如果指定为 ["*"]，或者不指定 allow_hosts，则表示无限制
from starlette.middleware.trustedhost import TrustedHostMiddleware
app.add_middleware(TrustedHostMiddleware, allowed_hosts=["a.example.com", "b.example.com"])

# 如果用户的请求头的 Accept-Encoding 字段包含 gzip，那么 FastAPI 会使用 GZip 算法压缩
# minimum_size=1000 表示当大小不超过 1000 字节的时候就不压缩了
from starlette.middleware.gzip import GZipMiddleware
app.add_middleware(TrustedHostMiddleware, minimum_size=1000)
```

**除了这些，还有其它的一些内置的中间件，可以自己查看一下，不过不是很常用。**

#### CORS

**CORS 过于重要，我们需要单独拿出来说。**

**CORS（跨域资源共享）是指浏览器中运行的前端里面拥有和后端通信的 JavaScript 代码，而前端和后端处于不同源的情况。源：协议（http、https）、域（baidu.com、app.com、localhost）以及端口（80、443、8000），只要有一个不同，那么就是不同源。比如下面都是不同的源：**

- `http://localhost`
- `https://localhost`
- `http://localhost:8080`

**即使它们都是 localhost，但是它们使用了不同的协议或端口，所以它们是不同的源。假设你的前端运行在 localhost:8080，并且尝试与 localhost:5555 进行通信；然后浏览器会向后端发送一个 HTTP OPTIONS 请求，后端会发送适当的 headers 来对这个源进行授权；所以后端必须有一个 "允许的源" 列表，如果前端对应的源是被允许的，浏览器才会允许前端向后端发请求，否则就会出现跨域失败。**

**而默认情况下，前后端必须是在同一个源，如果不同源那么前端就会请求失败。而前后端分离早已成为了主流，因此跨域问题是必须要解决的。**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    # 允许跨域的源列表，例如 ["http://www.example.org"] 等等，["*"] 表示允许任何源
    allow_origins=["*"],
    # 跨域请求是否支持 cookie，默认是 False，如果为 True，allow_origins 必须为具体的源，不可以是 ["*"]
    allow_credentials=False,
    # 允许跨域请求的 HTTP 方法列表，默认是 ["GET"]
    allow_methods=["*"],
    # 允许跨域请求的 HTTP 请求头列表，默认是 []，可以使用 ["*"] 表示允许所有的请求头
    # 当然 Accept、Accept-Language、Content-Language 以及 Content-Type 总之被允许的
    allow_headers=["*"],
    # 可以被浏览器访问的响应头, 默认是 []，一般很少指定
    # expose_headers=["*"]
    # 设定浏览器缓存 CORS 响应的最长时间，单位是秒。默认为 600，一般也很少指定
    # max_age=1000
)

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**以上即可解决跨域问题。**

## 高阶操作

**下面我们看一些 FastAPI 的高阶操作，这些操作有的不一定能用上，但用上了确实会方便许多。**

### 其它的响应

**返回 json 数据可以是：JSONResponse、UJSONResponse、ORJSONResponse，Content-Type 是 application/json；返回 html 是 HTMLResponse，Content-Type 是 text/html；返回 PlainTextResponse，Content-Type 是 text/plain。但是我们还可以有三种响应，分别是返回重定向、字节流、文件。**

#### 重定向

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
from fastapi.responses import RedirectResponse
import uvicorn

app = FastAPI()


@app.get("/index")
async def index():
    return RedirectResponse("https://www.bilibili.com")


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**页面中访问 /index 会跳转到 bilibili。**

#### 字节流

**返回字节流需要使用异步生成器的方式：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import uvicorn

app = FastAPI()

async def some_video():
    for i in range(5):
        yield f"video {i} bytes ".encode("utf-8")

@app.get("/index")
async def index():
    return StreamingResponse(some_video())


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020903635-685973224.png)

**如果有文件对象，那么也是可以直接返回的。**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import uvicorn

app = FastAPI()


@app.get("/index")
async def index():
    return StreamingResponse(open("main.py", encoding="utf-8"))


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020909512-1944912533.png)

#### 文件

**返回文件的话，还可以通过 FileResponse：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
from fastapi.responses import FileResponse
import uvicorn

app = FastAPI()

@app.get("/index")
async def index():
    # filename 如果给出，它将包含在响应的 Content-Disposition 中。
    return FileResponse("main.py", filename="这不是main.py")

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**可以自己发请求测试一下。**

### HTTP 验证

**如果当用户访问某个请求的时候，我们希望其输入用户名和密码来确认身份的话该怎么做呢？**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI, Depends
from fastapi.security import HTTPBasic, HTTPBasicCredentials
import uvicorn

app = FastAPI()

security = HTTPBasic()

@app.get("/index")
async def index(credentials: HTTPBasicCredentials = Depends(security)):
    return {"username": credentials.username, "password": credentials.password}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**当用户访问 /index 的时候，会提示输入用户名和密码：**

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020916955-540735640.png)

**输入完毕之后，信息会保存在 credentials，我们可以获取出来进行验证。**

### websocket

**然后我们来看看 FastAPI 如何实现 websocket：**

```Python
# -*- coding:utf-8 -*-
# @Author: komeiji satori
from fastapi import FastAPI
from fastapi.websockets import WebSocket
import uvicorn

app = FastAPI()

@app.websocket("/ws")
async def ws(websocket: WebSocket):
    await websocket.accept()
    while True:
        # websocket.receive_bytes()
        # websocket.receive_json()
        data = await websocket.receive_text()
        await websocket.send_text(f"收到来自客户端的回复: {data}")

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=5555)
```

**然后我们通过浏览器进行通信：**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <script>
        ws = new WebSocket("ws://localhost:5555/ws");
 
        //如果连接成功, 会打印下面这句话, 否则不会打印
        ws.onopen = function () {
            console.log('连接成功')
        };
 
        //接收数据, 服务端有数据过来, 会执行
        ws.onmessage = function (event) {
            console.log(event)
        };
 
        //服务端主动断开连接, 会执行.
        //客户端主动断开的话, 不执行
        ws.onclose = function () {  }
 
    </script>
</body>
</html>
```

![img](%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6.assets/1229382-20210506020924119-1504124962.png)

## FastAPI 服务的部署

**目前的话，算是介绍了 FastAPI 的绝大部分内容，然后我们来看看 FastAPI 服务的部署，其实部署很简单，直接 uvicorn.run 即可。但是这里面有很多的参数，我们主要是想要介绍这些参数。**

```Python
def run(app, **kwargs):
    config = Config(app, **kwargs)
    server = Server(config=config)
    ...
    ...
```

**我们看到 app 和 \**kwargs 都传递给了 Config，所以我们只需要看 Config 里面都有哪些参数即可。这里选出一部分：**

- `app：第一个参数，不需要解释`
- `host：监听的ip`
- `port：监听的端口`
- `uds：绑定的 unix domain socket，一般不用`
- `fd：从指定的文件描述符中绑定 socket`
- `loop：事件循环实现，可选项为 auto|asyncio|uvloop|iocp`
- `http：HTTP 协议实现，可选项为 auto|h11|httptools`
- `ws：websocket 协议实现，可选项为 auto|none|websockets|wsproto`
- `lifespan：lifespan 实现，可选项为 auto|on|off`
- `env_file：环境变量配置文件`
- `log_config：日志配置文件`
- `log_level：日志等级`
- `access_log：是否记录日志`
- `use_colors：是否带颜色输出日志信息`
- `interface：应用接口，可选 auto|asgi3|asgi2|wsgi`
- `debug：是否开启 debug 模式`
- `reload：是否自动重启`
- `reload_dirs：要自动重启的目录`
- `reload_delay：多少秒后自动重启`
- `workers：工作进程数`
- `limit_concurrency：并发的最大数量`
- `limit_max_requests：能 hold 住的最大请求数`

## 小结

**总的来说，FastAPI 算是当前最流行的异步框架了，并且它完全可以在生产中使用，是值得信赖的。当然使用异步框架，最重要的是要搭配一个异步驱动去访问数据库，因为 web 服务的瓶颈都是在数据库上面。**