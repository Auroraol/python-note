# 21.UDP、TCP 网络编程



 1 网络编程 

 1 互联网协议 

●互联网协议包含上百种协议标准，由于最重要的两个协议是TCP和IP协议，因此大家把互联网协议简称为TCP/IP协议

 2 IP 

 1 IP协议 

●负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去

●由于互联网链路复杂，两台计算机之间经常有多线路，因此路由器负责决定加何把一个IP包转发出去

●IP包的特点是按块发送，途经多个路由，但不保证能到达，也不保顺利到达

●IP地址实际上是一个20位整数(IPv4)，以字符串表示的IP地址实际上是把32位整数按8位分组后的数字表示(如192.168.0.1)，目的是便于阅读

●IPv6地址实际上是128位整数，是目前使用的IPV4地址的升级版，以字符串表示类似于2001:0db8:85a3:0042:1000:8a2e:0370:7334

●目前计算机的网络类型中，ipv4应用于PC端，ipv6应用于移动端

 2 IP地址 

●互联网中的标识符，并且在局域网中是唯一的

●window系统通过执行命令行命令：ipconfig 查询ip地址

 3 端口 

●如果我想用一台计算机中软件的向另一台计算机中的同一软件发送消息，仅仅知道IP地址是不够的

●需要通过这个软件所占用的端口来进行消息发送，端口用于定位软件

 1 端口号 

●端口是通过端口号来进行分配的

●端口号只有整数，范围是：0-65535

 2 端口分配 

●端口号不是随意使用的，而是按照一定的规定进行分配

 1 知名端口 

●知名端口是众所周知的端口号，范围从0-1023

 2 动态端口 

●动态端口的范围是从1024-65535

●之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配

●动态分配是指当一个系统程序或应用程序程序需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用

●当这个程序关闭时，同时也就释放了所占用的端口号



 1 socket的使用 

●socket，简称套接字，是进程间通信的一种方式

●它与其他进间通信的一个主要不同是：它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于socket来完成通信的

●三次握手 四次挥手

 1 UDP网络编程 

 1 UDP 通信模型 

●创建一个基于UDP的网络程序流程很简单，具体步骤如下

a创建客户端套接字

b发送/接收数据

c关闭套接字

![udp.jpg](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/1670827083976-822f1008-2c0e-4310-b0d5-cd9c82b92443.jpeg)

UDP 通信模型



 2 导入socket模块 



 3 创建套接字对象 

●第一个参数 AF_INET 代表：ipv4

●第二个参数 SOCK_DGRAM 代表：udp



 4 指定接收方的ip和port 



 5 端口绑定 

●绑定端口信息，防止端口随机分配，推荐端口号：1024-10000

●将设置好的地址载入socket对象中



 6 发送信息 

●发送信息需要将字符串转为字节类型，window系统要指定编码集为gbk



 7 接收信息 

●程序阻塞，直到接收到信息为止

●一次性可以接收的最大的字节数：1024



 8 关闭套接字 

●关闭套接字，释放端口



 2 TCP网络编程 

 1 TCP 协议 

●TCP协议，传输控制协议(英语: Transmission Control Protocol，缩写为 TCP)

●是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义

●TCP通信需要经过创建连接、数据传送、终止连接三个步聚

●TCP通信模型中，在通信开始之前，一定要先建立相关的链接、才能发送数据，类似于生活中"打电话"

 2 TCP 的特点 

 1 面向连接 

●通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。

●双方间的数据传输都可以通过这一个连接进行

●完成数据交换后，双方必须断开此连接，以释放系统资源

●这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议

 2 可靠传输 

●TCP采用发送应答机制：TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功

●超时重传：发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对E成功收到的包发回一个相应的确认ACK);如果发送端实体在合理的往返时延RTT内未收到确认，那么对应的数据包京被假设为已丢失将会被进行重传

●错误校验：TCP用一个校验和函数来检验数据是否有错误;在发送和接收时都要计算校验和

●流量控制和阻塞管理：流量控制用来避免主机发送得过快而使接收方来不及完全收下

 3 TCP与 UDP 的区别 

●面向连接 (确认有创建三方交握，连接已创建才作传输)

●有序数据传输

●重发丢失的数据包

●舍弃重复的数据包

●无差错的数据传输

●阻塞/流量控制(减轻服务器传输压力

 4 TCP 注意事项 

●tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器

●tcp客户端一般不绑定，因为是主动连接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机

●tcp服务器中通过 listen 可以将 socket 创建出来的主动套接字变为被动的，这是做 tcp 服务器时必须要做的

●当客户端需要连接服务器时，就需要使用 connect 进行链接，udp是不需要连接的而是直接发送，但是tcp必须先连接，只有链接成功才能通信

●当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务

●listen 后的套接字是 被动套接字，用来接收新的客户端的链接请求的，而 accept 返回的新套接字是标记这个新客户端的

●关闭 listen 后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信

●关闭 accept 返回的套接字意味着这个客户端已经服务完毕9.当客户端的套接字调用 close 后，服务器端会 recv 解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来别客户端是否已经下线

 3 TCP 通信模型 

![tcp.png](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/1670829449057-263d5849-d954-45fe-a488-6e4a3f3c5686.png)

TCP 通信模型





 4 TCP客户端操作 

 1 创建TCP套接字对象 

●第一个参数 AF_INET 代表：ipv4

●第二个参数 SOCK_STREAM 代表：tcp



 2 连接TCP服务器 



 3 发送信息 



 4 接受信息 

●程序阻塞，直到接收到信息为止

●一次性可以接收的最大的字节数：1024



 5 关闭套接字 



 5 TCP服务器操作 

 1 TCP 服务器代码构建 

●socket：创建一个套接字

●bind：绑定ip和port

●listen：使套接字变为可以被动连接

●accept：等待客户端的连接

●recv/send：接收/发送数据

 2 创建TCP套接字对象 



 3 绑定ip和port 



 4 套接字转变为被动连接 

●最大可以支持128个客户端的连接



 5 等待客户端的连接 

●程序阻塞，直到客户端连接为止

●返回一个元组

●第一个元素：套接字对象，用于数据发送/数据接收

●第二个元素：对方的ip和port



 6 接收信息 

●程序阻塞，直到接收到信息为止

●一次性可以接收的最大的字节数：1024



 7 发送信息 



 8 关闭套接字 



 6 文件下载器 

 1 TCP客户端 



1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

import socket

def main():

​    \# 创建tcp套接字对象

​    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

​    \# 建立连接

​    server_ip = '192.168.159.1'

​    server_port = 8080

​    tcp_client_socket.connect((server_ip, server_port))

​    print(f'已连接服务器 {server_ip}:{server_port}')

​    \# 发送信息

​    send_message = input('请输入文件名:')

​    tcp_client_socket.send(send_message.encode('gbk'))

​    \# 接收信息

​    recv_message = tcp_client_socket.recv(1024)

​    if recv_message:

​        with open('new_' + send_message, mode='wb') as file:

​            file.write(recv_message)

​        print('接收完毕！')

​    else:

​        print('文件已损坏！')

if __name__ == '__main__':

​    main()

 2 TCP服务器 





Python

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

import socket

def get_file(file_name):

​    try:

​        with open(file_name, mode='rb') as file:

​            content = file.read()

​            if content:

​                return content

​    except FileNotFoundError:

​        print(f'文件 {file_name} 不存在或已损坏！')

def main():

​    \# 创建tcp套接字对象

​    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

​    \# 绑定信息

​    server_address = ('', 8080)

​    tcp_server_socket.bind(server_address)

​    \# 监听模式

​    tcp_server_socket.listen(128)

​    while True:

​        \# 返回 接收/发送 数据的套接字对象 客户端的ip地址和port

​        new_socket, client_address = tcp_server_socket.accept()

​        print(f'客户端 {client_address[0]}:{client_address[1]} 已连接...')

​        \# 接收信息

​        recv_message = new_socket.recv(1024)

​        file_name = recv_message.decode('gbk')

​        print(f'客户端下载的文件：{file_name}')

​        \# 发送信息

​        \# content 是字节对象，不需要encode编码

​        file_data = get_file(file_name)

​        if file_data:

​            send_message = new_socket.send(file_data)

​            print('发送完毕！')

​            \# 关闭套接字

​        new_socket.close()

if __name__ == '__main__':

​    main()